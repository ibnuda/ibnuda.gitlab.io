<!DOCTYPE html>
<html>
 <head>
  <title>Nothing Unusual</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <meta name="description" content="page content."/>
  <meta name="author" content="IbnuDA"/>
  <link rel="stylesheet" href="static/milligram.min.css"/>
  <link rel="stylesheet" href="static/normalize.min.css"/>
  <link rel="stylesheet" href="static/main.css"/>
 </head>
 <body>
  <main class="wrapper">
   <nav class="navigation">
    <section class="container">
     <a class="navigation-title" href="/">
      Home
     </a>
    </section>
   </nav>
   <section class="container">
    <h1>Parsing and Tweeting</h1>
<p>At <code>$WORK</code>, I'm getting a lot of information that have to be parsed in form of
text file.
Whether it's from email, log files, and stuffs like that.
So, I guess I have to automate those information parsing to ease my life a bit.</p>
<p>Here's what I've done.</p>
<ul>
<li>Read file.</li>
<li>Parse stuff.</li>
<li>Spit out those parsed stuff to whatever I want.</li>
</ul>
<p>And for this article, I want to put the parsed information of a dumped-archive of
a whatsapp chat group, create a sequence of random words using markov-chain,
and then tweet it.
(The tweet part is just a cherry on top, actually)</p>
<h3>Data Format</h3>
<p>Basically, a dumped archive of WhatsApp chat looks like the following format.</p>
<pre><code>{DateTime}{CommaSeparator}{Whitespace}{Dash}{Whitespace}{Sender}{Colon}{Whitespace}{Message}
</code></pre>
<p>where</p>
<ul>
<li><code>{DateTime}</code> is the date and time of the message sent, minus the second part.</li>
<li><code>{CommaSeparator}</code> is a char of <code>,</code>.</li>
<li><code>{Whitespace}</code> is a char of <code></code>.</li>
<li><code>{Dash}</code> is a char of <code>-</code>.</li>
<li><code>{Sender}</code>, as far as I know, is an array of valid utf8 characters.</li>
<li><code>{Colon}</code> is a char of <code>:</code>.</li>
<li><code>{Message}</code> could be a multiline array of utf8 characters.
While it could contains medias, we will ommit it for the sake of simplicity.</li>
</ul>
<pre><code>20/01/2018, 10:10 - Ibnu Daru Aji: This is a message.
20/01/2018, 10:11 - Ibnu Daru Aji: This is a message.

</code></pre>
<h3>Parsing</h3>
<p>We will use haskell package, <code>attoparsec</code>, to parse it.
The following snippet parses the <code>DateTime</code> token:</p>
<pre><code>import qualified Data.Attoparsec.ByteString.Char8 as BC

ParserDatum :: Parser UTCTime
parserDatum = do
  dd &lt;- count 2 BC.digit
  _ &lt;- BC.char '/'
  mm &lt;- count 2 BC.digit
  _ &lt;- BC.char '/'
  yyyy &lt;- count 4 BC.digit
  _ &lt;- string &quot;, &quot;
  hh &lt;- count 2 BC.digit
  _ &lt;- BC.char ':'
  m &lt;- count 2 BC.digit
  _ &lt;- string &quot; - &quot;
  pure $
    UTCTime
    { utctDay = fromGregorian (read yyyy) (read mm) (read dd)
    , utctDayTime = secondsToDiffTime $ (read hh) * 3600 + (read m) * 60
    }
</code></pre>
<p>The reason why I use <code>UTCTime</code> is I'm familiar with it and there's no particular
constraints that I have.
And then <code>dd</code>, <code>mm</code>, <code>yyyy</code>, <code>hh</code>, and <code>m</code> are the parsed parts of the <code>{DateTime}</code>
token of the messages, respectively.
Each parts with <code>count</code> function mean that we have to take <code>n</code> char of <code>digit</code>.
There's a few things that should be given attentions, for example, I skipped a few
characters and there's no seconds part.
Finally, we will return a parser that return an instance of <code>UTCTime</code>.</p>
<pre><code>parserVerzender :: Parser ByteString
parserVerzender = do
  BC.takeTill (== ':')

parserPraat :: Parser ByteString
  rest &lt;- BC.takeTill (== '\n')
  end &lt;- atEnd
  if end
    then pure rest
    else (BC.char '\n') &gt;&gt; pure rest
</code></pre>
<p>The functions in the snippet above are used to parse <code>{Sender}</code> and <code>{Message}</code>.
Basically, the <code>parserVerzender</code> only takes characters until <code>:</code> char and <code>parserPraat</code>
takes characters until a new line.</p>
<pre><code>parserBericht :: Parser Bericht
parserBericht = do
  date &lt;- parserDatum
  crimineel &lt;- parserVerzender
  _ &lt;- take 2
  a &lt;- parserPraat
  b &lt;- manyTill parserPraat $ endOfInput &lt;|&gt; isDatumAhead
  pure $ Bericht date crimineel $ concat $ splitAtSpace a : map splitAtSpace b

isDatumAhead :: Parser ()
isDatumAhead = lookAhead parserDatum *&gt; pure ()

splitAtSpace :: ByteString -&gt; [ByteString]
splitAtSpace = BS.split (' ')

data Bericht = Bericht
  { datum   :: UTCTime
  , sender  :: ByteString
  , content :: [ByteString]
  }
</code></pre>
<p><code>parserBericht</code> function combines</p>
<ul>
<li><code>parserDatum</code> to parse date.</li>
<li><code>parserVerzender</code> to parse sender.</li>
<li>skip two characters.</li>
<li>takes many lines until end of input or the first few characters of a new line
could be parsed to a <code>{DateTime}</code>.</li>
<li>then, returns a <code>Bericht</code> object.
<code>isDatumAhead</code> is a parser that look a head whether the next input could be parsed
as <code>DateTime</code> or not.
And the reason why there's a <code>splitAtSpace</code> is because we want it as per words
for the input of markov chain in the next section.</li>
</ul>
<p>And because there are many messages, we will create type and parser for that.</p>
<pre><code>type ChatLog = [Bericht]
parserChatLog = many parserBericht
</code></pre>
<h3>Cherries on Top</h3>
<p>We will use <code>markov-chain</code> package to generate the data we will tweet.</p>
<pre><code>import qualified Data.Attoparsec.Lazy as AP
import qualified Data.ByteString as B
import Data.MarkovChain
import System.Random

parseFile :: FilePath -&gt; IO ChatLog
parseFile filename = do
  fileContent &lt;- B.readFile filename
  case AP.parseOnly parserChatLog fileContent of
    Right chats -&gt; return chats
    Left _      -&gt; pure []

generateBullshit :: [[ByteString]] -&gt; StdGen -&gt; ByteString
generateBullshit fileContents randomSeed =
  B.intercalate &quot; &quot; $ take 20 $ concat $ runMulti 1 fileContent 0 randomSeed
</code></pre>
<p>We will parse the file
And use the <a href="https://github.com/himura/twitter-conduit/tree/master/sample">sample</a>
of the <code>twitter-conduit</code> package to tweet the result of <code>generateBullshit</code> function.</p>
<h3>Main Function</h3>
<pre><code>mainFunc :: IO ()
mainFunc = do
  randomSeed &lt;- getStdGen
  twInfo &lt;- getTwInfoFromProxy
  mgr &lt;- newManager tlsManagerSettings
  args &lt;- getArgs
  case args of
    file:namen -&gt; do
      fileContent &lt;- parseFile file
      let chats =
            (map content) . (filter (\bericht -&gt; sender bericht `elem` map BC.pack namen)) $
            fileContent
      let bullshit = generateBullshit chats randomSeed
      putStrLn $ T.decodeUtf8 bullshit
      res &lt;- call twInfo mgr $ update $ T.decodeUtf8 bullshit
      print res
    _ -&gt; do
      putStrLn (&quot;&lt;this program&gt; &lt;file archive&gt; &lt;usernames&gt;&quot; :: Text)
      exitFailure
</code></pre>
<p>That function will:</p>
<ul>
<li>create a random seed.</li>
<li>create twinfo (from the samples of <code>twitter-conduit</code>)</li>
<li>create tls manager.</li>
<li>get arguments from command line.</li>
<li>when the arguments are less than than two, the program will error.</li>
<li>when the argements more than two, the program will:
<ul>
<li>take the first argument as the filename of the caht archive.</li>
<li>take the rest of the arguments to decide which sender's messages which
will be used as the input of <code>generateBullshit</code> function.</li>
<li>tweet the result of generated chain.</li>
</ul>
</li>
</ul>
<p>All in all, it was a nice learning experience for a short weekend.
You can read the whole program <a href="https://gitlab.com/ibunda/Tiwik">here</a>.</p>

   </section>
  </main>
 </body>
</html>
