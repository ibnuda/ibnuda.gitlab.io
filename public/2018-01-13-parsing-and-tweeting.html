<!DOCTYPE HTML>

<html>
    <head>
        <meta name="viewport" value="width=device-width, initial-scale=1.0">
        <meta name="description" value="Parsing and Tweeting
====================

At `$WORK`, I&#39;m getting a lot of information that have to be parsed in form of
text file.
Whether it&#39;s from email, log files, and stuffs like that.
So, I gue">
        <meta name="author" value="Ibnu D. Aji">
        <link rel="stylesheet" type="text/css" href="static/css/milligram.min.css">
        <title>
            Nothing Unusual
        </title>
    </head>
    <body>
        <main class="wrapper">
            <nav class="navigation">
                <section class="container">
                    <a class="navigation-title" href="index.html">
                        Home
                    </a>
                    <ul class="navigation-list float-right">
                        <li class="navigation-item">
                            <a href="2018-01-01-about.html" class="navigation-link">
                                About
                            </a>
                        </li>
                    </ul>
                </section>
            </nav>
            <section class="container">
                <h1>Parsing and Tweeting</h1><p>At <code>$WORK</code>, I'm getting a lot of information that have to be parsed in form of
text file.
Whether it's from email, log files, and stuffs like that.
So, I guess I have to automate those information parsing to ease my life a bit.</p><p>Here's what I've done.
- Read file.
- Parse stuff.
- Spit out those parsed stuff to whatever I want.</p><p>And for this article, I want to put the parsed information of a dumped-archive of
a whatsapp chat group, create a sequence of random words using markov-chain,
and then tweet it.
(The tweet part is just a cherry on top, actually)</p><h3>Data Format</h3><p>Basically, a dumped archive of WhatsApp chat looks like the following format.</p><pre><code>{DateTime}{CommaSeparator}{Whitespace}{Dash}{Whitespace}{Sender}{Colon}{Whitespace}{Message}</code></pre><p>where
- <code>{DateTime}</code> is the date and time of the message sent, minus the second part.
- <code>{CommaSeparator}</code> is a char of <code>,</code>.
- <code>{Whitespace}</code> is a char of <code> </code>.
- <code>{Dash}</code> is a char of <code>-</code>.
- <code>{Sender}</code>, as far as I know, is an array of valid utf8 characters.
- <code>{Colon}</code> is a char of <code>:</code>.
- <code>{Message}</code> could be a multiline array of utf8 characters.
  While it could contains medias, we will ommit it for the sake of simplicity.</p><pre><code>20/01/2018, 10:10 - Ibnu Daru Aji: This is a message.
20/01/2018, 10:11 - Ibnu Daru Aji: This is a message.
</code></pre><h3>Parsing</h3><p>We will use haskell package, <code>attoparsec</code>, to parse it.
The following snippet parses the <code>DateTime</code> token:</p><pre><code>import qualified Data.Attoparsec.ByteString.Char8 as BC

ParserDatum :: Parser UTCTime
parserDatum = do
  dd &lt;- count 2 BC.digit
  _ &lt;- BC.char '/'
  mm &lt;- count 2 BC.digit
  _ &lt;- BC.char '/'
  yyyy &lt;- count 4 BC.digit
  _ &lt;- string &quot;, &quot;
  hh &lt;- count 2 BC.digit
  _ &lt;- BC.char ':'
  m &lt;- count 2 BC.digit
  _ &lt;- string &quot; - &quot;
  pure $
    UTCTime
    { utctDay = fromGregorian (read yyyy) (read mm) (read dd)
    , utctDayTime = secondsToDiffTime $ (read hh) * 3600 + (read m) * 60
    }</code></pre><p>The reason why I use <code>UTCTime</code> is I'm familiar with it and there's no particular
constraints that I have.
And then <code>dd</code>, <code>mm</code>, <code>yyyy</code>, <code>hh</code>, and <code>m</code> are the parsed parts of the <code>{DateTime}</code>
token of the messages, respectively.
Each parts with <code>count</code> function mean that we have to take <code>n</code> char of <code>digit</code>.
There's a few things that should be given attentions, for example, I skipped a few
characters and there's no seconds part.
Finally, we will return a parser that return an instance of <code>UTCTime</code>.</p><pre><code>parserVerzender :: Parser ByteString
parserVerzender = do
  BC.takeTill (== ':')

parserPraat :: Parser ByteString
  rest &lt;- BC.takeTill (== '\n')
  end &lt;- atEnd
  if end
    then pure rest
    else (BC.char '\n') &gt;&gt; pure rest</code></pre><p>The functions in the snippet above are used to parse <code>{Sender}</code> and <code>{Message}</code>.
Basically, the <code>parserVerzender</code> only takes characters until <code>:</code> char and <code>parserPraat</code>
takes characters until a new line.</p><pre><code>parserBericht :: Parser Bericht
parserBericht = do
  date &lt;- parserDatum
  crimineel &lt;- parserVerzender
  _ &lt;- take 2
  a &lt;- parserPraat
  b &lt;- manyTill parserPraat $ endOfInput &lt;|&gt; isDatumAhead
  pure $ Bericht date crimineel $ concat $ splitAtSpace a : map splitAtSpace b

isDatumAhead :: Parser ()
isDatumAhead = lookAhead parserDatum *&gt; pure ()

splitAtSpace :: ByteString -&gt; [ByteString]
splitAtSpace = BS.split (' ')

data Bericht = Bericht
  { datum   :: UTCTime
  , sender  :: ByteString
  , content :: [ByteString]
  }</code></pre><p><code>parserBericht</code> function combines
- <code>parserDatum</code> to parse date.
- <code>parserVerzender</code> to parse sender.
- skip two characters.
- takes many lines until end of input or the first few characters of a new line
  could be parsed to a <code>{DateTime}</code>.
- then, returns a <code>Bericht</code> object.
<code>isDatumAhead</code> is a parser that look a head whether the next input could be parsed
as <code>DateTime</code> or not.
And the reason why there's a <code>splitAtSpace</code> is because we want it as per words
for the input of markov chain in the next section.</p><p>And because there are many messages, we will create type and parser for that.</p><pre><code>type ChatLog = [Bericht]
parserChatLog = many parserBericht</code></pre><h3>Cherries on Top</h3><p>We will use <code>markov-chain</code> package to generate the data we will tweet.</p><pre><code>import qualified Data.Attoparsec.Lazy as AP
import qualified Data.ByteString as B
import Data.MarkovChain
import System.Random

parseFile :: FilePath -&gt; IO ChatLog
parseFile filename = do
  fileContent &lt;- B.readFile filename
  case AP.parseOnly parserChatLog fileContent of
    Right chats -&gt; return chats
    Left _      -&gt; pure []

generateBullshit :: [[ByteString]] -&gt; StdGen -&gt; ByteString
generateBullshit fileContents randomSeed =
  B.intercalate &quot; &quot; $ take 20 $ concat $ runMulti 1 fileContent 0 randomSeed</code></pre><p>We will parse the file 
And use the <a href="https://github.com/himura/twitter-conduit/tree/master/sample">sample</a>
of the <code>twitter-conduit</code> package to tweet the result of <code>generateBullshit</code> function.</p><h3>Main Function</h3><pre><code>mainFunc :: IO ()
mainFunc = do
  randomSeed &lt;- getStdGen
  twInfo &lt;- getTwInfoFromProxy
  mgr &lt;- newManager tlsManagerSettings
  args &lt;- getArgs
  case args of
    file:namen -&gt; do
      fileContent &lt;- parseFile file
      let chats =
            (map content) . (filter (\bericht -&gt; sender bericht `elem` map BC.pack namen)) $
            fileContent
      let bullshit = generateBullshit chats randomSeed
      putStrLn $ T.decodeUtf8 bullshit
      res &lt;- call twInfo mgr $ update $ T.decodeUtf8 bullshit
      print res
    _ -&gt; do
      putStrLn (&quot;&lt;this program&gt; &lt;file archive&gt; &lt;usernames&gt;&quot; :: Text)
      exitFailure</code></pre><p>That function will:
- create a random seed.
- create twinfo (from the samples of <code>twitter-conduit</code>)
- create tls manager.
- get arguments from command line.
- when the arguments are less than than two, the program will error.
- when the argements more than two, the program will:
  - take the first argument as the filename of the caht archive.
  - take the rest of the arguments to decide which sender's messages which
    will be used as the input of <code>generateBullshit</code> function.
  - tweet the result of generated chain.</p><p>All in all, it was a nice learning experience for a short weekend.
You can read the whole program <a href="https://gitlab.com/ibunda/Tiwik">here</a>.</p>
            </section>
        </main>
    </body>
</html>
