<!DOCTYPE HTML>

<html>
    <head>
        <meta name="viewport" value="width=device-width, initial-scale=1.0, user-scalable=yes">
        <meta name="description" value="# Telegram Bot and Something (WIP)

One of my friend asked for a help.
Though this time from a different person and on different problem.
We are going to build a bot for Telegram instant messenger ser">
        <meta name="author" value="Ibnu D. Aji">
        <link rel="stylesheet" type="text/css" href="static/css/milligram.min.css">
        <title>
            Nothing Unusual - Telegram Bot and Something
        </title>
    </head>
    <body>
        <main class="wrapper">
            <nav class="navigation">
                <section class="container">
                    <a class="navigation-title" href="index.html">
                        Home
                    </a>
                    <ul class="navigation-list float-right">
                        <li class="navigation-item">
                            <a href="2018-01-01-about.html" class="navigation-link">
                                About
                            </a>
                        </li>
                    </ul>
                </section>
            </nav>
            <section class="container">
                <h1>Telegram Bot and Something (WIP)</h1><p>One of my friend asked for a help.
Though this time from a different person and on different problem.
We are going to build a bot for Telegram instant messenger service which talks to database.
For the sake of giving an example, let's say that we will create a telegram bot which
records the income and expense.
Words of caution: trust me, it's really hairy and ugly.</p><p>Okay, let's start the mess.</p><h3>Preparation</h3><p>Just type <code>stack new OurBot new-template</code> into your terminal and then modify <code>stack.yaml</code>.
Insert the following lines in it</p><pre><code># stack.yaml
packages:
- .
- location:
    git: https://github.com/fizruk/telegram-bot-simple
    commit: c1cc6bbba14ca79c897586e2de28433193c0b9fd
  extra-dep: true
</code></pre><p>Which means that we will use that git repo (on that specified commit) on our program.
As for the reason, I failed to compile <a href="https://hackage.haskell.org/package/telegram-api"><code>telegram-api</code></a>
in the server I'm deploying to.</p><p>And then we will modify <code>package.yaml</code> to include the repo above as one of our dependencies.</p><pre><code># package.yaml
dependencies:
- base &gt;= 4.7 &amp;&amp; &lt; 5
- telegram-bot-simple
</code></pre><p>Where <code>telegram-bot-simple</code> is the name of the library which we previously included
in our <code>stack.yaml</code>.</p><p>Let's build it for a giggle by issuing <code>stack build</code> at the project's root directory.
It should compile just fine, I guess.</p><p>Next, we will create our domain model.</p><h3>Database Thingy</h3><p>We will add a few dependencies in our <code>package.yaml</code>.</p><ul><li><code>persistent</code> for talking to database.</li><li><code>persistent-postgresql</code> for talking to postgresql, specifically.</li><li><code>persistent-template</code>, it eases our life a bit. Though prolong the compile time.</li><li><code>esqueleto</code> it's nice to join the tables in a <del>bar</del> database.</li><li><code>text</code>, I just like <code>Text</code>.</li><li><code>time</code></li></ul><p>Then, we will create a file named <code>Model.hs</code> in our <code>src</code> directory and include it
as one of our source files.</p><p>To simplify a bit, we will create two tables named <code>income</code> and <code>expense</code>.
The <code>income</code> table will have <code>source</code> (<code>Text</code>), <code>amount</code> (<code>Double</code>), and <code>when</code> (<code>UTCTime</code>) while <code>expense</code>
table will have <code>towhom</code> (<code>Text</code>), <code>amount</code> (<code>Double</code>), and <code>when</code> (<code>UTCTime</code>).</p><p>In order to accomplish that, we will edit <code>Model.hs</code> as the following</p><pre><code>-- Model.hs
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeFamilies #-}
module Model where

import Data.Text
import Data.Time
import Database.Persist.TH
import Database.Persist.Sql

share
  [mkPersist sqlSettings, mkMigrate &quot;migrateAll&quot;]
  [persistLowerCase|
    Income
      source Text
      amount Double
      when   UTCTime
      deriving Show Eq
    Expense
      towhom Text
      amount Double
      when   UTCTime
      deriving Show Eq
  |]
</code></pre><p>On a second glance, I just realized that we use so many language extensions.
As for the reasons, apart from <code>QuasiQuotes</code> and <code>TemplateHaskell</code>, I don't really
know and just accept that GHC will fail to compile without them.
But if you insist, you can look at the <a href="http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html">docs</a>
about them.</p><p>Anyway, the snippet above, especially the <code>share</code> block, defines that we will
create tables name <code>income</code> and <code>expense</code>, which we have specified before the snippet.</p><p>And for the &quot;migration plan&quot;, just a fancy way to say about creating and/or dropping
tables and/or database before the program talks to it, we will create a function
named <code>doMigration</code> in the same source file.</p><pre><code>-- Model.hs
doMigration :: SqlPersistT IO ()
doMigration = runMigration migrateAll
</code></pre><p>If you wonder where did <code>migrateAll</code> come from, that value comes from the
<code>share</code> block above.
You can see <code>&quot;migrateAll&quot;</code> there. That's the magic of <code>Template Haskell</code>.</p><h4>Read Write</h4><p>Let's start by adding <code>monad-logger</code>, <code>monad-control</code>, and <code>transformers</code> in our
<code>package.yaml</code> with the reason of satisfying a constraint of one of our functions.</p><p>We then create a source file named <code>ReadWrite.hs</code> on our <code>src</code> dir.
It will be really messy and we will have a lot of duplicated functions.
For example, a function like this:</p><pre><code>-- ReadWrite.hs
insertIncome :: Text -&gt; Double -&gt; IO (Key Income)
insertIncome source amount = do
  now &lt;- getCurrentTime
  runDb $ insert $ Income source amount now

insertExpense :: Text -&gt; Double -&gt; IO (Key Expense)
insertExpense towhom amount = do
  now &lt;- getCurrentTime
  runDb $ insert $ Expense towhom amount now
</code></pre><p>To be honest, I don't really know how to reduce the duplication.
But that's another homework I have to solve for the next article, I guess.</p><p>Okay, let's import library for <code>ReadWrite.hs</code>.</p><pre><code>-- ReadWrite.hs
import Control.Monad.IO.Class
import Control.Monad.Logger
import Control.Monad.Trans.Control
import Control.Monad.Trans.Reader

import Data.Text
import Data.Time
import Data.Maybe

import Database.Persist.Postgresql (withPostgresqlConn)
import Database.Esqueleto
</code></pre><p>As you've seen, there are a lot of <code>Control.Monad</code> libraries.
Those libraries are used as the wrapper in our functions.
And the reason is the program we write communicates with <code>RealWorld(tm)</code> and
thus the data from/to our functions is safe.</p><p>And don't forget to sprinkle some extensions so GHC can decide what kind of data
we are using in the program.</p><pre><code>-- ReadWrite.hs
{-# LANGUAGE AllowAmbiguousTypes   #-}
{-# LANGUAGE FlexibleContexts      #-}
{-# LANGUAGE GADTs                 #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings     #-}
{-# LANGUAGE Rank2Types            #-}
{-# LANGUAGE RankNTypes            #-}
{-# LANGUAGE TypeFamilies          #-}
</code></pre><p>As usual, I really suggest you to read through GHC's documentation to get the
explanations we need (or want) over what those extension do (or don't).</p><p>Finally, we come to the simplest part of the program, read write information
to the database.</p><pre><code>-- ReadWrite.hs
--| For executing queries.
runDb ::
     (MonadIO m, MonadBaseControl IO m)
  =&gt; ReaderT SqlBackend (LoggingT m) a
  -&gt; m a
runDb query = do
  -- Yep, you read that right.
  -- There's password and username hardcoded for db in here.
  let con = &quot;host=localhost port=5432 user=ibnu dbname=bot password=jaran&quot;
  runStderrLoggingT $ withPostgresqlConn con $ \backend -&gt; runReaderT query backend
</code></pre><p>The function above takes a query, which is a read-only access to the database.
&quot;Read-only&quot; what I mean here is, in a sense, a paved road built by government.
You can't modify it, yet you can freely use it.
Also, we have to use an instance of <code>LoggingT</code> for this function (by appending <code>runStderrLoggingT</code>)
to satisfy the demands from <code>withPostgresqlConn</code> so it can execute the query properly.</p><p>After we wrote the executor, we will write the functions to read and write from/to database.
The snippet about <code>insert</code> above pretty much enough for our need of insert at the moment.
And for querying, we will create a few functions.</p><pre><code>-- ReadWrite.hs
searchIncomeBySource ::
  (MonadBaseControl IO m, MonadIO m) =&gt; Text -&gt; m [Income]
searchIncomeBySource source = do
  incomes &lt;-
    runDb $
    select $
    from $ \inc -&gt; do
      where_ (inc ^. IncomeSource ==. val source)
      limit 10
      orderBy [desc (inc ^. IncomeWhen)]
      return inc
  return $ map entityVal incomes
</code></pre><p>The snippet above queries the database to select from table <code>income</code> which satisfy
the condition (<code>IncomeSource</code> equals to its argument) but only takes 10 rows and
orders it based on <code>when</code> column.</p><p>As I've complained above, about too many function duplications, we can create
a function for expense by replacing 4 token.
Just replace <code>Income</code> to <code>Expense</code> and presto! we have the function we want.</p><p>There's a really rough edge on this file, though.</p><pre><code>totalExpense ::
     ( BaseBackend backend ~ SqlBackend
     , PersistUniqueRead backend
     , PersistQueryRead backend
     , IsPersistBackend backend
     , MonadIO m
     )
  =&gt; ReaderT backend m Double
totalExpense = do
  res &lt;- select $ from $ \exp -&gt; return $ joinV $ sum_ (exp ^. ExpenseAmount)
  return $ head $ map (fromJust . unValue) res

balance :: IO Double
balance = do
  inc &lt;- runDb totalIncome
  exp &lt;- runDb totalExpense
  return $ inc - exp
</code></pre><p>The function <code>totalExpense</code> above disregards three possibilities:</p><ul><li>The table could be empty, thus the <code>res</code> value could be an empty list.</li><li>Because <code>res</code> could be an empty list, the function <code>head</code> is not safe at all.</li><li>And because <code>sum_</code>'s return value is <code>Maybe a</code>, the usage of <code>fromJust</code> is a really bad.</li></ul><p>The same goes for many other functions we need. 
You can read it <a href="https://gitlab.com/ibnuda/Telegram-Bot-Walkthrough/blob/feeb49d60a626047f4689072d29a0b3a06a4558f/src/ReadWrite.hs">here</a>
if you want to read the rest.</p><h4>Types and Action</h4><p>If you read the example from <a href="https://github.com/fizruk/telegram-bot-simple">telegram-bot-simple</a>,
you will know that the approach of this library is pretty similar to <a href="https://github.com/dmjio/miso">miso</a>'s
or Elm's approach on state management.
And that means we have to define our <code>model</code> and <code>action</code> where every action on every state (or <code>model</code>)
maybe has a different effects on it.</p><p>So, let's define our <code>model</code> by open <code>Lib.hs</code> file on <code>src</code> dir.</p><pre><code>-- Lib.hs
import Model
import ReadWrite

import Control.Applicative ((&lt;|&gt;))
import Data.Maybe
import Data.Text
import Telegram.Bot.API
import Telegram.Bot.Simple
import Telegram.Bot.Simple.UpdateParser
</code></pre><p>Just standard imports.
Nothing particularly interesting here.</p><pre><code>-- Lib.hs
data ChatState
  = IncomeOrExpense Text Double
  | InsertingIncome
  | InsertingIncomeSavedSource Text
  | InsertingExpense
  | InsertingExpenseSavedToWhom Text
  | SearchingIncome
  | SearchingExpense
  | CheckingBalance
  | Other Text
  | EmptyContent
  deriving (Show, Eq)
</code></pre><p>We defined a sumtype named <code>ChatState</code> to model the state of the application.
Because we can't really know the intention of the user when inserting, ah screw it.
Let me show you an example.</p><pre><code>        You: /income
Bot: Who gave you the money?
        You: Mom
Bot: How much is it?
        You: 420
Bot: Okay, saved!
</code></pre><p>Because the nature of the conversation, we can't really rely on the program's &quot;inteligence&quot;.
It's a hard problem in NLP, isn't it?
And we don't even use that.
So, the easiest approach is we hold the state and saved input in the program itself as
the <code>state</code>.</p><p>Same goes for the other functions, we only need to take <code>n - 1</code> arguments, if any, before
we call the corresponding query functions.</p><pre><code>-- Lib.hs
data ChatModel =
  ChatModel ChatState
  deriving (Show, Eq)

emptyChatModel = ChatModel EmptyContent

data Action
  = Empty
  | ActHelp
  | ActAddInc
  | ActAddExp
  | ActSearchIncome
  | ActSearchExpense
  | ActAddExp
  | ActAddMessageText Text
  | ActAddMessageDouble Double
  deriving (Show, Read)
</code></pre><p>On the snippet above, we defined <code>ChatState</code> as, well, the the state of the application
plus its content; or <code>model</code> in Elm's lingo.
We also defined <code>Action</code> that limits what could be done on this program.
For example, <code>ActHelp</code> is an action that will be used to tell the program to
show the user the &quot;help messages.&quot;
And let the <code>Action</code> derives from <code>Show</code> and <code>Read</code> because we need them to be &quot;show-able&quot;
and &quot;read-able&quot;.</p><p>Next, we will create an &quot;app representation&quot; of our session by adding the following lines.</p><pre><code>-- Lib.hs
incexpBotApp :: BotApp ChatModel Action
incexpBotApp = BotApp
  { botInitialModel = emptyChatModel
  , botAction = flip updateToAction
  , botHandler = updateHandler
  , botJobs = []
  }
</code></pre><p>The defined structure of the <code>BotApp</code> specifies what could be done when given a specific <code>Update</code>.
Oh, forgot to tell, the message we (and bot) send is called <code>Update</code> in this package.</p><p>At the moment, <code>updateToAction</code> and <code>updateHandler</code> haven't been defined yet.
So take a moment to define those functions.</p><pre><code>-- Lib.hs
updateToAction :: ChatModel -&gt; Update -&gt; Maybe Action
updateToAction _ = parseUpdate $
  ActHelp &lt;$ command (pack &quot;help&quot;) &lt;|&gt;
  ActBalance &lt;$ command (pack &quot;balance&quot;) &lt;|&gt;
  ActAddInc &lt;$ command (pack &quot;income&quot;) &lt;|&gt;
  ActAddExp &lt;$ command (pack &quot;expense&quot;) &lt;|&gt;
  ActSearchIncomes &lt;$  command (pack &quot;incomes&quot;) &lt;|&gt;
  ActSearchExpenses &lt;$ command (pack &quot;expense&quot;) &lt;|&gt;
  ActMessage &lt;$ plainText &lt;|&gt;
  callbackQueryDataRead
</code></pre><p>This <code>updateAction</code> function basically takes any kind of chat models and parses any update it has given to
by read the message's text (<code>Update</code> has a lot of data in it).
If the message's text starts with a slash (<code>/</code>) then it will return the appropriate action.
But when the message's text does'nt start with a slash, it should regard the message's text as <code>ActMessage</code>.</p>
            </section>
        </main>
    </body>
    <footer>
        This material is shared under the 
        <a href="https://creativecommons.org/licenses/by/4.0">
            CC-BY License.
        </a>
    </footer>
</html>
