<!DOCTYPE HTML>

<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" value="width=device-width, initial-scale=1.0, user-scalable=yes">
        <meta name="description" value="# Static Blog Generator

The previous blog engine, which was written in F#, was not really satisfying for me.
For example, I couldn&#39;t add a different kind of post without breaking things up.
Furthermo">
        <meta name="author" value="Ibnu D. Aji">
        <link rel="stylesheet" type="text/css" href="static/css/milligram.min.css">
        <title>
            Nothing Unusual - Static Blog Generator
        </title>
    </head>
    <body>
        <main class="wrapper">
            <nav class="navigation">
                <section class="container">
                    <ul class="navigation-list float-left">
                        <li class="navigation-item">
                            <a href="index.html" class="navigation-link">
                                Home
                            </a>
                        </li>
                    </ul>
                    <ul class="navigation-list float-right">
                        <li class="navigation-item">
                            <a href="2018-03-31-cv.html" class="navigation-link">
                                CV
                            </a>
                        </li>
                        <li class="navigation-item">
                            <a href="2018-01-01-about.html" class="navigation-link">
                                About
                            </a>
                        </li>
                    </ul>
                </section>
            </nav>
            <section class="container">
                <h1>Static Blog Generator</h1><p>The previous blog engine, which was written in F#, was not really satisfying for me.
For example, I couldn't add a different kind of post without breaking things up.
Furthermore, it was really ugly; even for me who has very low standard of ugliness.</p><p>And then when I decided to write a new one, I realized that backward compatibility
was a real pain in the back.
So, I abandoned the backward support and wrote a new one from scratch and in haskall.</p><p>It shouldn't be either a program that has a lot of constraints and features like Hakyll
nor it would be a mess like my previous blog generator (you could laugh it
<a href="https://gitlab.com/ibnuda/ibnuda.gitlab.io/tree/master/fs">here</a>).</p><h4>Gathering the Requirements</h4><p>What I wanted from a blog program was just it had to have the following features:</p><ul><li>Generates htmls from markdowns.</li><li>Has two &quot;kinds&quot; of posts. For example, a normal post which displayed at the index
and a special page, like &quot;about&quot;.</li><li>Generates index which based on the existing written posts.</li><li>Can be hosted in any http server.</li><li>Can create new post using command line.</li></ul><h4>Design, I Guess</h4><p>Based on the previous wanted features, I decided to create a datatype like this.</p><pre><code>data Content = Content
  { filename    :: Text
  , mdTitle     :: Text
  , mdDate      :: UTCTime
  , contentType :: Text
  , contentText :: Text
  } deriving (Show, Eq)
</code></pre><p>The snippet above represents the datatype which I thought could represents the entity
of the posts that have been written.
Whether it's the normal posts or the special posts.
As you can see, the <code>contentType</code> field represents that.
And if you wanted to ask &quot;Why didn't you create a sum type for the content type&quot;, I was
too lazy to do that.</p><p>Other than the <code>Content</code> data wrapper, I also defined the data wrapper for configuration.
I heard that it is bad to hard-code strings or whatever into the program.
As a good sheep as I am, I created <code>Configuration</code> for the site.</p><pre><code>data Configuration = Configuration
  { siteURL       :: Text
  , siteName      :: Text
  , author        :: Text
  , pathPages     :: Text
  , pathPosts     :: Text
  , pathGenerated :: Text
  } deriving (Show, Eq)
</code></pre><p>Though it just a couple of strings that used to define which directory the posts are stored
and boring stuff like that.</p><h4>Markdown Read/Write</h4><p>Basically, when I want to create a new post I just want to type &quot;something new title&quot; and
the program should handle the rest.
For example, the date of the writing being created, location of where should the markdown
be written, etc.</p><p>About that, I decided to write a function that takes two arguments, the type of the post
and the title.</p><p>So, I wrote the following function.</p><pre><code>createMarkdownFile :: Text -&gt; Text -&gt; IO ()
createMarkdownFile cType cTitle = do
  now &lt;- getCurrentTime
  let filename = mdFilenameFromTitle cTitle
      dir =
        case cType of
          &quot;page&quot; -&gt; &quot;pages&quot;
          &quot;post&quot; -&gt; &quot;posts&quot;
          _      -&gt; &quot;posts&quot; :: Text
  writeContent $
    Content (filename &lt;&gt; &quot;.md&quot;) cTitle now dir &quot;# Write Here!!!\nPlease.&quot;
</code></pre><p>That function above &quot;normalises&quot; the title (so can be written without escape,
as seen in<code>mdFilenameFromTitle</code>) into the proper directory.</p><p>And when I want to &quot;compile&quot; the markdown files to html files, I should be able to
read the markdown files. Thus I write this function</p><pre><code>write :: Text -&gt; Text -&gt; Text -&gt; IO ()
write ctype fname content =
  writeFile (unpack ctype ++ &quot;/&quot; ++ unpack fname) content
</code></pre><p>Which is just a wrapper for <code>Data.Text.IO.writeFile</code> while append the name content type
and fname as the real filename of the written file.
While reading the file, I wanted it the same, I put two arguments (type and filename)
and will get a <code>Content</code> object.</p><pre><code>readIndividualFile :: Text -&gt; [Char] -&gt; IO Content
readIndividualFile above nameOfFile = do
  content &lt;- readFile fn
  case lines content of
    title:date:writing -&gt;
      pure $
      Content (pack nameOfFile) title (TR.read $ unpack date) above $
      unlines writing
    _ -&gt; pure emptyContent
  where
    fn = unpack above ++ &quot;/&quot; ++ nameOfFile
</code></pre><p>Considering the structure of the written markdown file,</p><pre><code>This is the Title
2018-01-01 01:11:11.111111111 UTC --This is the date
# This is the Title
</code></pre><p>I had to skip two lines of the content of the file. Yeah, innefficient, I know.
Especially when I use the strict version of the <code>Data.Text.IO</code>, then load it
into memory, then <code>lines</code> it, and finally create a <code>Content</code> object (which also
<code>unlines</code> those <code>[Text]</code>).</p><h4>Generating HTML</h4><p>After the markdown files are succesfully read, the program only had to parse the
markdown content of the <code>Content</code> object into HTML and then write it into the
<code>pathGenerated</code>.
Though it's not that straightforward.</p><p>In order to generate HTML, I don't know, I feel stupid:</p><ol><li>Read the all of the contents of the <code>pathPages</code> and <code>pathPosts</code> directory.</li><li>Generate the navbar.</li><li>Hold it in the memory.</li><li>While at it, gnerate the HTML contents from those two <code>paths</code> (with the navbar from number 2, obv.)</li><li>Generate index from a list of read <code>Content</code>s  from <code>pathPosts</code> directory.</li><li>Write the html files of the generated posts.</li><li>Write the index.</li><li>Write the generated pages from the step number 1.</li></ol><p>I feel ashamed of myself. But well, at the moment, this program serves its purpose well,
I guess.</p>
            </section>
        </main>
    </body>
    <footer>
        This material is shared under the 
        <a href="https://creativecommons.org/licenses/by/4.0">
            CC-BY License.
        </a>
    </footer>
</html>
