<!DOCTYPE HTML>

<html>
    <head>
        <meta name="viewport" value="width=device-width, initial-scale=1.0">
        <meta name="description" value="Chiron 7 Tutorial
=======================

Well, [Chiron](https://github.com/xyncro/chiron) is an F# library for (de)serialization of Json. It&#39;s really well written.
If you ever used Elm&#39;s json serial">
        <meta name="author" value="Ibnu D. Aji">
        <link rel="stylesheet" type="text/css" href="static/css/milligram.min.css">
        <title>
            Nothing Unusual
        </title>
    </head>
    <body>
        <main class="wrapper">
            <nav class="navigation">
                <section class="container">
                    <a class="navigation-title" href="index.html">
                        Home
                    </a>
                    <ul class="navigation-list float-right">
                        <li class="navigation-item">
                            <a href="2018-01-01-about.html" class="navigation-link">
                                About
                            </a>
                        </li>
                    </ul>
                </section>
            </nav>
            <section class="container">
                <h1>Chiron 7 Tutorial</h1><p>Well, <a href="https://github.com/xyncro/chiron">Chiron</a> is an F# library for (de)serialization of Json. It's really well written.
If you ever used Elm's json serialization, you will feel at home at no time.</p><p>Though I admit, there are a few of ceremonious parts of its usage, especially in enc/dec part.
But that's fine, there are prices that should be paid for flexibility. And furthermore, this library is really fun to be learned from.</p><h2>Instalation</h2><p>In standard netcore project (<code>.fsproj</code>), we can easily install it by entering the following command on the command line interface.</p><pre><code>dotnet add package -v 7.0.0-*</code></pre><p>And in your <code>.fsproj</code> file, you will see something like the following line.</p><pre><code>&lt;ItemGroup&gt;
  &lt;PackageReference Include=&quot;Chiron&quot; Version=&quot;7.0.0-*&quot; /&gt;
&lt;/ItemGroup&gt;</code></pre><h2>Terminologies:</h2><p>There are a few terminologies which will be used very often in the rest of the post.</p><ul><li><code>Json</code>: A discriminated union of <code>JsonObject</code>, <code>Json list</code>, <code>string</code>, <code>number</code>, <code>bool</code>, and <code>null</code>.</li><li><code>JsonResult&lt;'a&gt;</code>: Chiron's, using Walschin's term, elevated type. Something like <code>Option&lt;'a&gt;</code> but instead of <code>None</code> and <code>Some a</code> we will have <code>JsonFailure</code> and <code>JPass a</code>.</li><li><code>JsonObject</code>: I don't know how to word it correctly. But I'm sure it is Chiron's json object type representation.</li><li><code>JPass a</code>: Represent value a in elevated state.</li><li><code>JFail</code>: Instead of <code>null</code>, we will have <code>JsonFailure</code>, which could be parsing failure. Whether it's type mismatch, deserialization error, invalid json string, or something else.</li><li><code>Decoder&lt;'s, 'a&gt;</code>: Extract <code>'s</code> to the <code>JsonResult&lt;'a&gt;</code>.</li><li><code>ObjectReader&lt;'a&gt;</code>: A <code>JsonDecoder&lt;'a&gt;</code> &quot;creator&quot; with a <code>JsonObject</code> as the first type parameter.</li><li><code>ObjectBuilder&lt;'a&gt;</code>: Again, a function to build a <code>JsonObject</code> from an <code>'a</code> object.</li><li><code>JsonDecoder&lt;'a&gt;</code>: An elevator from type <code>'a</code> to <code>Decoder&lt;'s, 'a&gt;</code>.</li><li><code>JsonEncoder&lt;'a&gt;</code>: <code>JsonDecoder&lt;'a&gt;</code>'s counterpart. From a <code>Json</code> elevated state, to normal state.</li></ul><h2>Usages</h2><p>Define an object, as an example we will have a type and a nested type. I took it from my other project (<a href="https://gitlab.com/ibnuda/Forum/blob/master/src/Libr/Lock/AuthModels.fs">Forum</a>).</p><h3>Our Types</h3><pre><code>open Chiron
open Chiron.Operators

module AuthModels =

  type Qualification =
    { Id    : int
      Value : int
      Name  : string }
    static member Create (ide, value, name) =
      { Id    = ide
        Value = value
        Name  = name }

  type Token =
    { Quali     : Qualification
      UserId    : Guid
      ExpiresIn : int64 }
    static member Create (quali, uid, eIn) =
      { Quali     = quali
        UserId    = uid
        ExpiresIn = eIn }</code></pre><p>In the above code, we have imported <code>Chiron</code> and <code>Chiron.Operators</code> modules from the Chiron package. We will use that in a few minutes.
And there's an object type, named <code>Token</code>, which has <code>Quali</code> property, which in turn is a <code>Qualification</code>. That type has a static member which will be used in the module which has the same name as the specified object previously.</p><p>Then, we write the following code:</p><pre><code>module Qualification =
  let private create ide value name = Qualification.Create (ide, value, name)
  let encode qualif jsonObj =
    jsonObj
    |&gt; Json.Encode.required Json.Encode.int    &quot;id&quot;    qualif.Id
    |&gt; Json.Encode.required Json.Encode.int    &quot;value&quot; qualif.Value
    |&gt; Json.Encode.required Json.Encode.string &quot;name&quot;  qualif.Name
  let decode =
    create
    &lt;!&gt; Json.Decode.required Json.Decode.int    &quot;id&quot;
    &lt;*&gt; Json.Decode.required Json.Decode.int    &quot;value&quot;
    &lt;*&gt; Json.Decode.required Json.Decode.string &quot;name&quot;

module Token =
  let private create qualif uid ein = Token.Create (qualif, uid, ein)
  let private encodeQualif = Json.Encode.jsonObjectWith Qualification.encode
  let private decodeQualif = Json.Decode.jsonObjectWith Qualification.decode
  let encode token jsonObj =
    jsonObj
    |&gt; Json.Encode.required encodeQualif      &quot;qualification&quot; token.Quali
    |&gt; Json.Encode.required Json.Encode.guid  &quot;userid&quot;        token.UserId
    |&gt; Json.Encode.required Json.Encode.int64 &quot;expiresin&quot;     token.ExpiresIn
  let decode =
    create
    &lt;!&gt; Json.Decode.required decodeQualif      &quot;qualification&quot;
    &lt;*&gt; Json.Decode.required Json.Decode.guid  &quot;userid&quot;
    &lt;*&gt; Json.Decode.required Json.Decode.int64 &quot;expiresin&quot;</code></pre><h3>Functions' Explanation</h3><p>There are basically five things there.</p><pre><code>// create : int -&gt; int -&gt; name -&gt; Qualification
let private create ide value name = Qualification.Create (ide, value, name)</code></pre><p>This function will be used to create a <code>Qualification</code> object in the following code:</p><pre><code>let decode =
  create
  &lt;!&gt; Json.Decode.required Json.Decode.int    &quot;id&quot;
  &lt;*&gt; Json.Decode.required Json.Decode.int    &quot;value&quot;
  &lt;*&gt; Json.Decode.required Json.Decode.string &quot;name&quot;</code></pre><p>By defining <code>decode</code>, we have created a <code>Decoder</code> with two params, <code>JsonObject</code> as the input and <code>Token</code> as the output.
At the snippet above, there are two operators (which we've imported from <code>Chiron.Operators</code>). An operator <code>&lt;!&gt;</code> and operator <code>&lt;*&gt;</code>.</p><p>The <code>&lt;!&gt;</code> is a custom operator for <code>Decoder.map</code> which has the signature as the following:</p><pre><code>map : ('a -&gt; 'b) -&gt; Decoder&lt;'s, 'a&gt; -&gt; Decoder&lt;'s, 'b&gt;</code></pre><p>Just a standard <code>map</code> function, which transform a <code>Decoder</code> to another <code>Decoder</code>.</p><p>While <code>&lt;*&gt;</code> is a custom operator for <code>Decoder.apply</code> which has the signature as the following:</p><pre><code>apply : Decoder&lt;'s, 'a&gt; -&gt; Decoder&lt;'s, 'a -&gt; 'b&gt; -&gt; Decoder&lt;'s -&gt; 'b&gt;</code></pre><p>Again, standard <code>apply</code> function, which apply a parameter to a function (but in form of a <code>Decode</code> object).</p><p>So, the <code>decode</code> function above, also could be written as:</p><pre><code>let decode =
  Json.Decoder.map create (Json.Decode.required Json.Decode.int    &quot;id&quot;)
  |&gt; Json.Decoder.apply   (Json.Decode.required Json.Decode.int    &quot;value&quot;)
  |&gt; Json.Decoder.apply   (Json.Decode.required Json.Decode.string &quot;name&quot;)</code></pre><p>Basically, the <code>decode</code> function above means, in particular order of the <code>create</code> function's signature, we will take values from a <code>JsonObject</code>:</p><ol><li>Take an <code>int</code> value from the <code>JsonObject</code> which <b>should</b> has a field named <code>id</code>.</li><li>Then take an <code>int</code> value from the <code>JsonObject</code> which also <i>should</i> has a field named <code>value</code>.</li><li>Then take a <code>string</code> value from the <code>JsonObject</code> which also <i>should</i> has a field named <code>name</code>.</li><li>Apply the taken values above, in particular order of the <code>create</code> function's signature, to the <code>create</code> function.</li></ol><p>And the result is a decoder which will transfrom from <code>JsonObject</code> to <code>Qualification</code>.</p><p>Move on to the <code>encode</code> part which create an <code>ObjectBuilder&lt;Qualification&gt;</code> in the following code.</p><pre><code>let encode qualif jsonObj =
  jsonObj
  |&gt; Json.Encode.required Json.Encode.int    &quot;id&quot;    qualif.Id
  |&gt; Json.Encode.required Json.Encode.int    &quot;value&quot; qualif.Value
  |&gt; Json.Encode.required Json.Encode.string &quot;name&quot;  qualif.Name</code></pre><p>The <code>encode</code> function above means, we will take a <code>Qualification</code> object and another <code>JsonObject</code> and then do the following step.</p><ol><li>Take an <code>int</code> value of property <code>Id</code> of <code>qualif</code> object and put it into <code>jsonObj</code> with fieldname <code>&quot;id&quot;</code>.</li><li>Then take an <code>int</code> value of property <code>Value</code> of <code>qualif</code> object and put it into the result of step no 1 with fieldname <code>&quot;value&quot;</code>.</li><li>Then take a <code>string</code> value of property <code>Name</code> of <code>qualif</code> object and put it into the result of step no 2 with fieldname <code>&quot;name&quot;</code>.</li></ol><p>And the result is an <code>ObjectBuilder&lt;Qualification&gt;</code> which can be used to encode a <code>Qualification</code> object to a <code>JsonObject</code>, which in turn can be parsed to json string in the latter part of the post.</p><p>Next part is the explanation of <code>Token</code> module's functions. Let's take a look at these two functions.</p><pre><code>let private encodeQualif = Json.Encode.jsonObjectWith Qualification.encode
let private decodeQualif = Json.Decode.jsonObjectWith Qualification.decode</code></pre><p>First function, <code>encodeQualif</code>, is an encoder from a <code>Qualification</code> object to <code>Json</code> object. <code>Json.Encode.jsonObjectWith</code> itself basically function that takes an <code>ObjectBuilder</code> and gives result a <code>Json</code> object.
While the second function, <code>decodeQualif</code>, is a <code>Decoder&lt;Json, Qualification&gt;</code> object, <code>Json.Decode.jsonObjectWith</code> is that takes a decoder with input <code>JsonObject</code> and modify it to have <code>Json</code> input.
Those two previous functions will be used in the following functions.</p><pre><code>let decode =
  create
  &lt;!&gt; Json.Decode.required decodeQualif      &quot;qualification&quot;
  &lt;*&gt; Json.Decode.required Json.Decode.guid  &quot;userid&quot;
  &lt;*&gt; Json.Decode.required Json.Decode.int64 &quot;expiresin&quot;</code></pre><p>Basically, the <code>decode</code> function above means, in particular order of the <code>create</code> function's signature, we will take values from a <code>JsonObject</code>:</p><ol><li>Take a <code>Qualification</code> value from the <code>JsonObject</code> which <b>should</b> has a field named <code>qualification</code>.</li><li>Then take a <code>Guid</code> value from the <code>JsonObject</code> which also <i>should</i> has a field named <code>userid</code>.</li><li>Then take a <code>int64</code> value from the <code>JsonObject</code> which also <i>should</i> has a field named <code>expiresin</code>.</li><li>Apply the taken values above, in particular order of the <code>create</code> function's signature, to the <code>create</code> function.</li></ol><p>And the result is a decoder which will transfrom from <code>JsonObject</code> to <code>Token</code>.</p><pre><code>let encode token jsonObj =
  jsonObj
  |&gt; Json.Encode.required encodeQualif      &quot;qualification&quot; token.Quali
  |&gt; Json.Encode.required Json.Encode.guid  &quot;userid&quot;        token.UserId
  |&gt; Json.Encode.required Json.Encode.int64 &quot;expiresin&quot;     token.ExpiresIn</code></pre><p>The <code>encode</code> function above means, we will take a <code>Qualification</code> object and another <code>JsonObject</code> and then do the following step.</p><ol><li>Take a <code>Qualification</code> value of property <code>Qualif</code> of <code>token</code> object and put it into <code>jsonObj</code> with fieldname <code>&quot;qualification&quot;</code>.</li><li>Then take a <code>Guid</code> value of property <code>UserId</code> of <code>token</code> object and put it into the result of step no 1 with fieldname <code>&quot;userid&quot;</code>.</li><li>Then take an <code>int64</code> value of property <code>ExpiresIn</code> of <code>token</code> object and put it into the result of step no 2 with fieldname <code>&quot;expiresin&quot;</code>.</li></ol><p>And the result is an <code>ObjectBuilder&lt;Token&gt;</code> which can be used to encode a <code>Token</code> object to a <code>JsonObject</code>, which in turn can be parsed to json string in the latter part of the post.</p><h2>Serialisation and Deserialisation</h2><p>We will serialize a <code>Qualification</code> or a <code>Token</code> object to json string, using the following snippet</p><pre><code>let inline modelToJson (encoder : 'a -&gt; JsonObject -&gt; JsonObject) model =
  model
  |&gt; Json.Encode.jsonObjectWith encoder
  |&gt; Json.format</code></pre><p>The <code>modelToJson</code> function above takes a parameter which has a signature <code>'a -&gt; JsonObject -&gt; JsonObject</code> (or an <code>ObjectBuilder&lt;'a&gt;</code>) and an instance of object with type <code>'a</code>.
That function means:</p><ol><li>Build a <code>Json</code> object with an <code>ObjectBuilder&lt;'a&gt;</code> and an instance of <code>&lt;'a&gt;</code>.</li><li>Format it as json string.</li></ol><pre><code>let inline jsonToModel (decoder : JsonObject -&gt; JsonResult&lt;'a&gt;) jsonstr : 'a option =
  let parsingRes =
    jsonStr
    |&gt; Json.parse
    |&gt; JsonResult.bind (Json.Decode.jsonObjectWith decoder)
  match parsingRes with
  | JPass result -&gt; Some result
  | JFail _      -&gt; None</code></pre><p>And when we want to deserialise json string to an object, we will use the function <code>jsonToModel</code> above which takes a function which tranfrom <code>JsonObject</code> to <code>JsonResult&lt;'a&gt;</code> (or an <code>ObjectReader&lt;'a&gt;</code>) and a string which we assume as a json string. The result of that function is an option type of <code>'a</code>.
That function means :
  1. Parse the input, <code>jsonStr</code>. At this step, the result of the function is <code>JsonResult&lt;Json&gt;</code>.
  2. If the result parsed is <code>JPass json</code>, we will read the <code>json</code> using <code>ObjectReader&lt;'a&gt;</code>. Else, just return the <code>JFail jfailure</code>.
  3. Save the result of step 2 to <code>parsingRes</code>.
  4. If the <code>parsingRes</code> succesfully parsed, we will have <code>Some result</code>. Else, <code>None</code> will be returned.</p><h2>Example.</h2><p>The usage is something like this:</p><pre><code>let qualif = Qualification.Create (1, 1, &quot;Water&quot;) 
let token = Token.Create (qualif, Guid.Empty, 0L)

let jsonFromQualification = modelToJson Qualification.encode qualif

// result (beautified) :
// {
//   &quot;id&quot;:1,
//   &quot;value&quot;:1,
//   &quot;name&quot;:&quot;water&quot;
// }

let jsonFromToken = modelToJson Token.encode token

// result (beautified) : 
//{
//  &quot;qualification&quot;: {
//    &quot;id&quot;:1,
//    &quot;value&quot;:1,
//    &quot;name&quot;:&quot;water&quot;
//  },
//  &quot;userid&quot;:&quot;00000000-0000-0000-0000-000000000000&quot;,
//  &quot;expiresin&quot;:0
//}

let stringJsonToken =
&quot;&quot;&quot;{&quot;qualification&quot;:{&quot;id&quot;:1,&quot;value&quot;:1,&quot;name&quot;:&quot;water&quot;},&quot;userid&quot;:&quot;00000000-0000-0000-0000-000000000000&quot;,&quot;expiresin&quot;:0}&quot;&quot;&quot;
let stringJsonTokenWithoutUserid =
&quot;&quot;&quot;{&quot;qualification&quot;:{&quot;id&quot;:1,&quot;value&quot;:1,&quot;name&quot;:&quot;water&quot;},&quot;us&quot;:&quot;00000000-0000-0000-0000-000000000000&quot;,&quot;expiresin&quot;:0}&quot;&quot;&quot;

let tokenFromJson = jsonToModel Token.decode stringJsonToken
Assert.Equal (Some token, tokenFromJson)
let tokenFailParsed = jsonToModel Token.decode stringJsonTokenWithoutUserid
Assert.Equal (None, tokenFailParsed)
</code></pre>
            </section>
        </main>
    </body>
</html>
